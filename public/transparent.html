<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
      }

      #image-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
      }

      #png-image {
        position: absolute;
        display: none;
        -webkit-user-drag: none;
        transform-origin: center center;
      }

      /* Add controls for better navigation */
      .controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        gap: 5px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }

      body:hover .controls {
        opacity: 0.7;
      }

      .controls:hover {
        opacity: 1 !important;
      }

      .btn {
        background: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
      }

      .btn:hover {
        background: rgba(0, 0, 0, 0.9);
      }
    </style>
  </head>
  <body>
    <div id="image-container">
      <img id="png-image" alt="PNG Image" />
    </div>
    <div class="controls">
      <button class="btn" id="zoomIn" title="Zoom In">+</button>
      <button class="btn" id="zoomOut" title="Zoom Out">-</button>
      <button class="btn" id="zoomReset" title="Reset Zoom">↺</button>
      <button class="btn" id="closeBtn" title="Close">✕</button>
    </div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>

    <script>
      // Get elements
      const imageEl = document.getElementById('png-image');
      const imageContainer = document.getElementById('image-container');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const ctx = hitTestCanvas.getContext('2d');
      const controls = document.querySelector('.controls');
      const zoomInBtn = document.getElementById('zoomIn');
      const zoomOutBtn = document.getElementById('zoomOut');
      const zoomResetBtn = document.getElementById('zoomReset');
      const closeBtn = document.getElementById('closeBtn');
      
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      
      // For dragging
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let initialClickOnNonTransparent = false;

      // For zooming
      let scale = 1;
      const minScale = 0.1;
      const maxScale = 10;
      const scaleStep = 0.1;
      
      // Image positioning
      let imageX = 0;
      let imageY = 0;
      
      // Window dimensions
      let windowPadding = 50; // Padding to add around the image
      let resizeTimeout = null;

      // Listen for image data from the main process
      window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
        imagePath = path;
        imageEl.src = imageData;
        imageEl.style.display = 'block';
        
        // Once image is loaded, prepare hit-testing canvas
        imageEl.onload = () => {
          // Size canvas to match image
          hitTestCanvas.width = imageEl.naturalWidth;
          hitTestCanvas.height = imageEl.naturalHeight;
          
          // Draw the image onto the canvas for pixel data access
          ctx.drawImage(imageEl, 0, 0);

          // Initialize image position
          centerImage();
          
          // Initialize window dimensions based on image size
          updateWindowSize();

          // Initialize tracking
          initializeInteractions();
        };
      });
      
      // Center the image in the window
      function centerImage() {
        imageX = (window.innerWidth - imageEl.naturalWidth) / 2;
        imageY = (window.innerHeight - imageEl.naturalHeight) / 2;
        updateImagePosition();
      }
      
      // Update the image's position on screen
      function updateImagePosition() {
        imageEl.style.transform = `translate(${imageX}px, ${imageY}px) scale(${scale})`;
      }
      
      // Update window size based on current image dimensions and scale
      function updateWindowSize() {
        if (!imageEl.naturalWidth || !imageEl.naturalHeight) return;
        
        // Clear any pending resize
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        
        // Set a timeout to avoid too many resize operations
        resizeTimeout = setTimeout(() => {
          // Calculate the needed size based on the image dimensions and current position
          const boundsLeft = Math.min(0, imageX);
          const boundsRight = Math.max(window.innerWidth, imageX + imageEl.naturalWidth * scale);
          const boundsTop = Math.min(0, imageY);
          const boundsBottom = Math.max(window.innerHeight, imageY + imageEl.naturalHeight * scale);
          
          // Add padding
          const newWidth = boundsRight - boundsLeft + windowPadding * 2;
          const newHeight = boundsBottom - boundsTop + windowPadding * 2;
          
          // Set bounds for very large or small windows
          const maxWidth = window.screen.availWidth * 0.9;
          const maxHeight = window.screen.availHeight * 0.9;
          const minWidth = 300;
          const minHeight = 300;
          
          const targetWidth = Math.min(maxWidth, Math.max(minWidth, newWidth));
          const targetHeight = Math.min(maxHeight, Math.max(minHeight, newHeight));
          
          // Only resize if dimensions have changed significantly
          if (Math.abs(window.innerWidth - targetWidth) > 10 || 
              Math.abs(window.innerHeight - targetHeight) > 10) {
            
            // Calculate position offset to maintain visible portion
            const oldCenterX = window.innerWidth / 2;
            const oldCenterY = window.innerHeight / 2;
            
            // Resize the window
            window.transparentWindow.resize(targetWidth, targetHeight);
            
            // After resize, we'll need to adjust the image position
            // This happens in the resize event handler
          }
          
          resizeTimeout = null;
        }, 100); // Throttle resize events
      }

      // Check if a pixel at the given coordinates is transparent
      function isPixelTransparent(x, y) {
        // Convert window coordinates to image coordinates
        const rect = imageEl.getBoundingClientRect();
        
        // Check if coordinates are outside image bounds
        if (
          x < rect.left ||
          x > rect.right ||
          y < rect.top ||
          y > rect.bottom
        ) {
          return true;
        }

        // Calculate the exact pixel coordinates in the original image
        const imgX = Math.floor(((x - rect.left) / rect.width) * hitTestCanvas.width);
        const imgY = Math.floor(((y - rect.top) / rect.height) * hitTestCanvas.height);
        
        // Check if coordinates are within canvas bounds
        if (
          imgX < 0 || 
          imgX >= hitTestCanvas.width || 
          imgY < 0 || 
          imgY >= hitTestCanvas.height
        ) {
          return true;
        }

        // Get pixel data (RGBA)
        try {
          const pixelData = ctx.getImageData(imgX, imgY, 1, 1).data;
          // Check alpha channel (index 3) for transparency
          return pixelData[3] === 0;
        } catch (error) {
          console.error('Error checking pixel transparency:', error);
          return true; // Assume transparent on error
        }
      }

      function initializeInteractions() {
        // Handle mouse move for pixel transparency detection and dragging
        document.addEventListener('mousemove', (e) => {
          // Skip transparency check on controls
          if (e.target.closest('.controls')) {
            document.body.style.cursor = 'default';
            return;
          }
          
          // If dragging is in progress
          if (isDragging) {
            // Move the image with the mouse
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            
            imageX += deltaX;
            imageY += deltaY;
            
            // Update drag start position for next move
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // Apply the new position
            updateImagePosition();
            return;
          }
          
          // Not dragging, just check if we're over a non-transparent pixel
          isOverNonTransparentPixel = !isPixelTransparent(e.clientX, e.clientY);
          
          // Update cursor based on transparency
          document.body.style.cursor = isOverNonTransparentPixel ? 'move' : 'default';
        });

        // Initialize image dragging
        document.addEventListener('mousedown', (e) => {
          // Skip dragging if clicked on controls
          if (e.target.closest('.controls')) {
            return;
          }
          
          initialClickOnNonTransparent = !isPixelTransparent(e.clientX, e.clientY);
          
          if (initialClickOnNonTransparent) {
            // Start drag if clicked on non-transparent pixel
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            
            // Prevent default behaviors
            e.preventDefault();
          }
          // If clicked on transparent area, do nothing so the click passes through
        });

        // Handle drag end
        window.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            initialClickOnNonTransparent = false;
            
            // Update window size after drag ends
            updateWindowSize();
          }
        });

        // Also handle mouseup outside the window
        window.addEventListener('blur', () => {
          if (isDragging) {
            isDragging = false;
            initialClickOnNonTransparent = false;
            
            // Update window size after drag ends
            updateWindowSize();
          }
        });
        
        // Listen for key press to close window
        document.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'w' && isOverNonTransparentPixel) {
            window.transparentWindow.close();
          }
        });

        // Add mouse wheel event for zooming
        document.addEventListener('wheel', (e) => {
          // Only zoom if over the image or image container
          if (isOverNonTransparentPixel || e.target.closest('#image-container')) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            // Get mouse position
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // Calculate image-space coordinates before zoom
            const rect = imageEl.getBoundingClientRect();
            const imgMouseX = (mouseX - rect.left) / scale;
            const imgMouseY = (mouseY - rect.top) / scale;
            
            // Store old scale for calculation
            const oldScale = scale;
            
            // Calculate new scale based on wheel direction
            if (e.deltaY < 0) {
              // Scroll up - zoom in
              scale = Math.min(scale + scaleStep, maxScale);
            } else {
              // Scroll down - zoom out
              scale = Math.max(scale - scaleStep, minScale);
            }
            
            // Only proceed if scale actually changed
            if (oldScale !== scale) {
              // Calculate the new position to keep the mouse point fixed
              imageX = mouseX - imgMouseX * scale;
              imageY = mouseY - imgMouseY * scale;
              
              // Apply the new position and scale
              updateImagePosition();
              
              // Update window size
              updateWindowSize();
            }
          }
        }, { passive: false });
        
        // Add button controls
        zoomInBtn.addEventListener('click', () => {
          // Calculate center point of visible image
          const rect = imageEl.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          // Store img-space coordinates
          const imgCenterX = (centerX - imageX) / scale;
          const imgCenterY = (centerY - imageY) / scale;
          
          // Update scale
          const oldScale = scale;
          scale = Math.min(scale + scaleStep, maxScale);
          
          if (oldScale !== scale) {
            // Update position to keep center point fixed
            imageX = centerX - imgCenterX * scale;
            imageY = centerY - imgCenterY * scale;
            
            updateImagePosition();
            updateWindowSize();
          }
        });
        
        zoomOutBtn.addEventListener('click', () => {
          // Calculate center point of visible image
          const rect = imageEl.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          // Store img-space coordinates
          const imgCenterX = (centerX - imageX) / scale;
          const imgCenterY = (centerY - imageY) / scale;
          
          // Update scale
          const oldScale = scale;
          scale = Math.max(scale - scaleStep, minScale);
          
          if (oldScale !== scale) {
            // Update position to keep center point fixed
            imageX = centerX - imgCenterX * scale;
            imageY = centerY - imgCenterY * scale;
            
            updateImagePosition();
            updateWindowSize();
          }
        });
        
        zoomResetBtn.addEventListener('click', () => {
          scale = 1;
          centerImage();
          updateWindowSize();
        });
        
        closeBtn.addEventListener('click', () => {
          window.transparentWindow.close();
        });
        
        // Handle window resize events
        window.addEventListener('resize', () => {
          // We don't need to recenter the image - keep it where it is
          // Just update the window size if needed
          if (!resizeTimeout) {
            updateWindowSize();
          }
        });
      }
    </script>
  </body>
</html>