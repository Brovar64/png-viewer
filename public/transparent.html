<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
      }

      #image-container {
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        width: 100%;
        overflow: visible;
        background: transparent;
      }

      #png-image {
        position: relative;
        display: none;
        max-width: none;
        max-height: none;
        -webkit-user-drag: none;
        transform-origin: center center;
      }
    </style>
  </head>
  <body>
    <div id="image-container">
      <img id="png-image" alt="PNG Image" />
    </div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>

    <script>
      // Get elements
      const imageEl = document.getElementById('png-image');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const ctx = hitTestCanvas.getContext('2d');
      
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      
      // For dragging
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let initialClickOnNonTransparent = false;

      // For zooming
      let scale = 1;
      const minScale = 0.1;
      const maxScale = 10;
      const scaleStep = 0.1;

      // Last mouse position for smooth zooming
      let lastMouseX = 0;
      let lastMouseY = 0;
      let lastClientX = 0;
      let lastClientY = 0;

      // Window size tracking
      let currentWindowWidth = 0;
      let currentWindowHeight = 0;
      
      // Listen for image data from the main process
      window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
        imagePath = path;
        imageEl.src = imageData;
        imageEl.style.display = 'block';
        
        // Once image is loaded, prepare hit-testing canvas and initial sizing
        imageEl.onload = () => {
          // Size canvas to match image
          hitTestCanvas.width = imageEl.naturalWidth;
          hitTestCanvas.height = imageEl.naturalHeight;
          
          // Draw the image onto the canvas for pixel data access
          ctx.drawImage(imageEl, 0, 0);

          // Set a small initial timeout to ensure proper initial sizing
          setTimeout(() => {
            // Tell main process about the actual image dimensions for initial sizing
            const initialWidth = Math.min(imageEl.naturalWidth, 800);
            const initialHeight = Math.min(imageEl.naturalHeight, 600);
            currentWindowWidth = initialWidth;
            currentWindowHeight = initialHeight;
            window.transparentWindow.resizeWindow(initialWidth, initialHeight, 0, 0);
            
            // Apply initial scale
            applyScale();
  
            // Initialize tracking
            initializeInteractions();
          }, 50);
        };
      });

      // Apply the current scale to the image and resize window
      function applyScale(mouseX, mouseY, clientX, clientY) {
        // Apply the scale transform
        imageEl.style.transform = `scale(${scale})`;
        
        // Calculate dimensions with current scale
        const scaledWidth = Math.ceil(imageEl.naturalWidth * scale) + 40;  // Add padding
        const scaledHeight = Math.ceil(imageEl.naturalHeight * scale) + 40; // Add padding
        
        // Calculate mouse position relative to window (percentage)
        let relativeX = 0.5; // Default to center
        let relativeY = 0.5; // Default to center
        
        if (mouseX && mouseY && clientX !== undefined && clientY !== undefined) {
          // Use mouse position for zoom focus
          const rect = imageEl.getBoundingClientRect();
          relativeX = (clientX - rect.left) / rect.width;
          relativeY = (clientY - rect.top) / rect.height;
        }
        
        // Request window resize to fit the scaled image
        window.transparentWindow.resizeWindow(
          scaledWidth, 
          scaledHeight,
          relativeX,
          relativeY
        );
        
        // Update current window size
        currentWindowWidth = scaledWidth;
        currentWindowHeight = scaledHeight;
      }

      // Check if a pixel at the given coordinates is transparent
      function isPixelTransparent(x, y) {
        const rect = imageEl.getBoundingClientRect();
        
        // Check if coordinates are outside image bounds
        if (
          x < rect.left ||
          x > rect.right ||
          y < rect.top ||
          y > rect.bottom
        ) {
          return true;
        }

        // Convert window coordinates to image coordinates
        const imgX = Math.floor(((x - rect.left) / rect.width) * hitTestCanvas.width);
        const imgY = Math.floor(((y - rect.top) / rect.height) * hitTestCanvas.height);
        
        // Check if coordinates are within canvas bounds
        if (
          imgX < 0 || 
          imgX >= hitTestCanvas.width || 
          imgY < 0 || 
          imgY >= hitTestCanvas.height
        ) {
          return true;
        }

        // Get pixel data (RGBA)
        try {
          const pixelData = ctx.getImageData(imgX, imgY, 1, 1).data;
          // Check alpha channel (index 3) for transparency
          return pixelData[3] === 0;
        } catch (error) {
          console.error('Error checking pixel transparency:', error);
          return true; // Assume transparent on error
        }
      }

      function initializeInteractions() {
        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          lastMouseX = e.screenX;
          lastMouseY = e.screenY;
          lastClientX = e.clientX;
          lastClientY = e.clientY;
          
          // If dragging is in progress, always move the window regardless of current pixel
          if (isDragging) {
            try {
              // Ensure all values are proper numbers
              const screenX = Number(e.screenX);
              const screenY = Number(e.screenY);
              const offsetX = Number(dragOffsetX);
              const offsetY = Number(dragOffsetY);
              
              window.transparentWindow.drag(screenX, screenY, offsetX, offsetY);
            } catch (error) {
              console.error('Error during drag:', error);
              isDragging = false; // Stop dragging on error
            }
            return;
          }
          
          // Not dragging, just check if we're over a non-transparent pixel
          isOverNonTransparentPixel = !isPixelTransparent(e.clientX, e.clientY);
          
          // Update cursor based on transparency
          document.body.style.cursor = isOverNonTransparentPixel ? 'move' : 'default';
        });

        // Initialize window dragging
        document.addEventListener('mousedown', (e) => {
          initialClickOnNonTransparent = !isPixelTransparent(e.clientX, e.clientY);
          
          if (initialClickOnNonTransparent) {
            // Start drag if clicked on non-transparent pixel
            isDragging = true;
            
            // Calculate and store the click offset relative to the window
            const rect = imageEl.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Tell the main process dragging has started
            try {
              window.transparentWindow.startDrag();
            } catch (error) {
              console.error('Error starting drag:', error);
              isDragging = false;
            }
            
            // Prevent default behaviors
            e.preventDefault();
          }
          // If clicked on transparent area, do nothing so the click passes through
        });

        // Handle drag end
        window.addEventListener('mouseup', () => {
          isDragging = false;
          initialClickOnNonTransparent = false;
        });

        // Also handle mouseup outside the window
        window.addEventListener('blur', () => {
          isDragging = false;
          initialClickOnNonTransparent = false;
        });
        
        // Listen for key press to close window (only when over non-transparent pixels)
        document.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'w' && isOverNonTransparentPixel) {
            window.transparentWindow.close();
          }
        });

        // Add mouse wheel event for zooming
        document.addEventListener('wheel', (e) => {
          if (isOverNonTransparentPixel) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            // Calculate new scale based on wheel direction
            const oldScale = scale;
            
            if (e.deltaY < 0) {
              // Scroll up - zoom in
              scale = Math.min(scale + scaleStep, maxScale);
            } else {
              // Scroll down - zoom out
              scale = Math.max(scale - scaleStep, minScale);
            }
            
            // Only apply scale and resize window if scale actually changed
            if (oldScale !== scale) {
              // Pass current mouse position for centered zooming
              applyScale(lastMouseX, lastMouseY, e.clientX, e.clientY);
            }
          }
        }, { passive: false });
      }
    </script>
  </body>
</html>