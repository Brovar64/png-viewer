<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
        border: 2px solid #ff0000;
        box-sizing: border-box;
        border-radius: 4px;
      }

      #image-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: visible;
      }

      #png-image {
        position: relative;
        display: none;
        -webkit-user-drag: none;
        transform-origin: center center;
        border: 2px solid #ff0000;
      }

      /* Add controls for better navigation */
      .controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        gap: 5px;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.2s;
      }

      body:hover .controls {
        opacity: 0.7;
      }

      .controls:hover {
        opacity: 1 !important;
      }

      .btn {
        background: rgba(0, 0, 0, 0.6);
        color: white;
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s;
      }

      .btn:hover {
        background: rgba(0, 0, 0, 0.9);
      }
    </style>
  </head>
  <body>
    <div id="image-container">
      <img id="png-image" alt="PNG Image" />
    </div>
    <div class="controls">
      <button class="btn" id="zoomIn" title="Zoom In">+</button>
      <button class="btn" id="zoomOut" title="Zoom Out">-</button>
      <button class="btn" id="zoomReset" title="Reset Zoom">↺</button>
      <button class="btn" id="closeBtn" title="Close">✕</button>
    </div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>
    <canvas id="crop-canvas" style="display: none;"></canvas>

    <script>
      // Get elements
      const imageEl = document.getElementById('png-image');
      const imageContainer = document.getElementById('image-container');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const cropCanvas = document.getElementById('crop-canvas');
      const ctx = hitTestCanvas.getContext('2d');
      const cropCtx = cropCanvas.getContext('2d');
      const controls = document.querySelector('.controls');
      const zoomInBtn = document.getElementById('zoomIn');
      const zoomOutBtn = document.getElementById('zoomOut');
      const zoomResetBtn = document.getElementById('zoomReset');
      const closeBtn = document.getElementById('closeBtn');
      
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      let imageBounds = null;
      
      // For dragging
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let initialClickOnNonTransparent = false;

      // For zooming
      let scale = 1;
      const minScale = 0.1;
      const maxScale = 10;
      const scaleStep = 0.1;
      
      // Flag to track if we've already set the window size
      let windowSizeInitialized = false;

      // Function to find non-transparent edges of an image
      function findNonTransparentBounds(ctx, width, height) {
        let left = width;
        let right = 0;
        let top = height;
        let bottom = 0;
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // Scan through the entire image data
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const alpha = data[((y * width + x) * 4) + 3];
            
            if (alpha > 0) {
              left = Math.min(left, x);
              right = Math.max(right, x);
              top = Math.min(top, y);
              bottom = Math.max(bottom, y);
            }
          }
        }
        
        // Add a small padding to avoid clipping the image too tightly
        const padding = 1;
        left = Math.max(0, left - padding);
        top = Math.max(0, top - padding);
        right = Math.min(width - 1, right + padding);
        bottom = Math.min(height - 1, bottom + padding);
        
        // If no visible pixels are found, return null
        if (left > right || top > bottom) {
          return null;
        }
        
        return {
          left,
          top,
          right,
          bottom,
          width: right - left + 1,
          height: bottom - top + 1
        };
      }

      // Function to crop an image to its non-transparent content
      function cropToContent(sourceCanvas, bounds) {
        if (!bounds) return null;
        
        // Set crop canvas dimensions
        cropCanvas.width = bounds.width;
        cropCanvas.height = bounds.height;
        
        // Draw the cropped portion of the image onto the crop canvas
        cropCtx.drawImage(
          sourceCanvas,
          bounds.left, bounds.top, bounds.width, bounds.height,
          0, 0, bounds.width, bounds.height
        );
        
        return cropCanvas.toDataURL('image/png');
      }

      // Listen for image data from the main process
      window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
        imagePath = path;
        
        // Load image into temporary image element to get dimensions
        const tempImg = new Image();
        tempImg.onload = () => {
          // Size canvas to match image
          hitTestCanvas.width = tempImg.width;
          hitTestCanvas.height = tempImg.height;
          
          // Draw the image onto the canvas for pixel data access
          ctx.drawImage(tempImg, 0, 0);
          
          // Find non-transparent bounds
          imageBounds = findNonTransparentBounds(ctx, tempImg.width, tempImg.height);
          
          if (imageBounds) {
            // Crop the image to content
            const croppedImageData = cropToContent(hitTestCanvas, imageBounds);
            
            // Set the cropped image
            if (croppedImageData) {
              imageEl.src = croppedImageData;
            } else {
              // Fallback to original if cropping failed
              imageEl.src = imageData;
              imageBounds = null;
            }
          } else {
            // No non-transparent pixels found, use original
            imageEl.src = imageData;
          }
          
          imageEl.style.display = 'block';
          
          // Set initial scale
          updateScale();
          
          // Set window size only once on initial load
          if (!windowSizeInitialized) {
            // Use the original window size (600x600) from transparentWindow.js
            const initialWidth = 600;
            const initialHeight = 600;
            
            // Set the window size once, then never change it
            window.transparentWindow.resize(initialWidth, initialHeight, true);
            windowSizeInitialized = true;
          }
          
          // Initialize interaction handlers
          initializeInteractions();
        };
        
        // Set the source to the original image data to load it
        tempImg.src = imageData;
      });
      
      // Apply the scale without changing the centered position
      function updateScale() {
        imageEl.style.transform = `scale(${scale})`;
      }

      // Check if a pixel at the given coordinates is transparent
      function isPixelTransparent(x, y) {
        const rect = imageEl.getBoundingClientRect();
        
        // Check if coordinates are outside image bounds
        if (
          x < rect.left ||
          x > rect.right ||
          y < rect.top ||
          y > rect.bottom
        ) {
          return true;
        }

        // If we're using the cropped image
        if (imageBounds) {
          // For cropped images, we know any visible part is non-transparent
          // Just check if the point is within the image bounds
          return false;
        } else {
          // For uncropped images, use the original transparency check

          // Convert window coordinates to image coordinates
          const imgX = Math.floor(((x - rect.left) / rect.width) * hitTestCanvas.width);
          const imgY = Math.floor(((y - rect.top) / rect.height) * hitTestCanvas.height);
          
          // Check if coordinates are within canvas bounds
          if (
            imgX < 0 || 
            imgX >= hitTestCanvas.width || 
            imgY < 0 || 
            imgY >= hitTestCanvas.height
          ) {
            return true;
          }

          // Get pixel data (RGBA)
          try {
            const pixelData = ctx.getImageData(imgX, imgY, 1, 1).data;
            // Check alpha channel (index 3) for transparency
            return pixelData[3] === 0;
          } catch (error) {
            console.error('Error checking pixel transparency:', error);
            return true; // Assume transparent on error
          }
        }
      }

      function initializeInteractions() {
        // Handle mouse move for pixel transparency detection and dragging
        document.addEventListener('mousemove', (e) => {
          // Skip transparency check on controls
          if (e.target.closest('.controls')) {
            document.body.style.cursor = 'default';
            return;
          }
          
          // If dragging is in progress, handle window movement
          if (isDragging) {
            try {
              // Calculate how much the mouse has moved
              const deltaX = e.screenX - dragStartX;
              const deltaY = e.screenY - dragStartY;
              
              // Update the drag start position
              dragStartX = e.screenX;
              dragStartY = e.screenY;
              
              // Move the window
              window.transparentWindow.drag(e.screenX, e.screenY, deltaX, deltaY);
            } catch (error) {
              console.error('Error during drag:', error);
              isDragging = false; // Stop dragging on error
            }
            return;
          }
          
          // Not dragging, just check if we're over a non-transparent pixel
          isOverNonTransparentPixel = !isPixelTransparent(e.clientX, e.clientY);
          
          // Update cursor based on transparency
          document.body.style.cursor = isOverNonTransparentPixel ? 'move' : 'default';
        });

        // Initialize window dragging
        document.addEventListener('mousedown', (e) => {
          // Skip dragging if clicked on controls
          if (e.target.closest('.controls')) {
            return;
          }
          
          if (e.target.closest('#png-image')) {
            // If we clicked on the image, assume it's a non-transparent area
            // For cropped images, all visible pixels are non-transparent
            initialClickOnNonTransparent = true;
          } else {
            initialClickOnNonTransparent = false;
          }
          
          if (initialClickOnNonTransparent) {
            // Start drag if clicked on non-transparent pixel
            isDragging = true;
            dragStartX = e.screenX;
            dragStartY = e.screenY;
            
            // Tell the main process dragging has started
            try {
              window.transparentWindow.startDrag();
            } catch (error) {
              console.error('Error starting drag:', error);
              isDragging = false;
            }
            
            // Prevent default behaviors
            e.preventDefault();
          }
          // If clicked on transparent area, do nothing so the click passes through
        });

        // Handle drag end
        window.addEventListener('mouseup', () => {
          isDragging = false;
          initialClickOnNonTransparent = false;
        });

        // Also handle mouseup outside the window
        window.addEventListener('blur', () => {
          isDragging = false;
          initialClickOnNonTransparent = false;
        });
        
        // Listen for key press to close window (only when over non-transparent pixels)
        document.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 'w' && isOverNonTransparentPixel) {
            window.transparentWindow.close();
          }
        });

        // Add mouse wheel event for zooming
        document.addEventListener('wheel', (e) => {
          if (isOverNonTransparentPixel || e.target.closest('#image-container')) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            // Store pre-zoom scale for relative positioning
            const oldScale = scale;
            
            // Calculate new scale based on wheel direction
            if (e.deltaY < 0) {
              // Scroll up - zoom in
              scale = Math.min(scale + scaleStep, maxScale);
            } else {
              // Scroll down - zoom out
              scale = Math.max(scale - scaleStep, minScale);
            }
            
            // Only proceed if scale actually changed
            if (oldScale !== scale) {
              // Apply the new scale - this will scale from the center due to transform-origin
              updateScale();
            }
          }
        }, { passive: false });
        
        // Add button controls
        zoomInBtn.addEventListener('click', () => {
          scale = Math.min(scale + scaleStep, maxScale);
          updateScale();
        });
        
        zoomOutBtn.addEventListener('click', () => {
          scale = Math.max(scale - scaleStep, minScale);
          updateScale();
        });
        
        zoomResetBtn.addEventListener('click', () => {
          scale = 1;
          updateScale();
        });
        
        closeBtn.addEventListener('click', () => {
          window.transparentWindow.close();
        });
      }
    </script>
  </body>
</html>