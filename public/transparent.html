<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
      }

      #image-container {
        position: absolute;
        display: block;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

      #png-image {
        position: absolute;
        max-width: 100%;
        max-height: 100%;
        display: none;
        margin: auto;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        -webkit-user-drag: none;
      }
    </style>
  </head>
  <body>
    <div id="image-container">
      <img id="png-image" alt="PNG Image" />
    </div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>

    <script>
      // Get elements
      const imageEl = document.getElementById('png-image');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const ctx = hitTestCanvas.getContext('2d');
      
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      
      // For dragging
      let isDragging = false;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      // Listen for image data from the main process
      window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
        imagePath = path;
        imageEl.src = imageData;
        imageEl.style.display = 'block';
        
        // Once image is loaded, prepare hit-testing canvas
        imageEl.onload = () => {
          // Size canvas to match image
          hitTestCanvas.width = imageEl.naturalWidth;
          hitTestCanvas.height = imageEl.naturalHeight;
          
          // Draw the image onto the canvas for pixel data access
          ctx.drawImage(imageEl, 0, 0);

          // Initialize tracking
          updateHitTests();
        };
      });

      // Handle mouse move for pixel transparency detection
      function updateHitTests() {
        document.addEventListener('mousemove', (e) => {
          // Get mouse position relative to the image
          const rect = imageEl.getBoundingClientRect();
          if (
            e.clientX < rect.left ||
            e.clientX > rect.right ||
            e.clientY < rect.top ||
            e.clientY > rect.bottom
          ) {
            // Mouse is outside image bounds
            isOverNonTransparentPixel = false;
            document.body.style.cursor = 'default';
            return;
          }

          // Calculate position in the original image coordinates
          const x = Math.floor(((e.clientX - rect.left) / rect.width) * hitTestCanvas.width);
          const y = Math.floor(((e.clientY - rect.top) / rect.height) * hitTestCanvas.height);

          // Get pixel data (RGBA)
          const pixelData = ctx.getImageData(x, y, 1, 1).data;
          
          // Check alpha channel (index 3) for transparency
          isOverNonTransparentPixel = pixelData[3] > 0;
          
          // Update cursor based on transparency
          if (isOverNonTransparentPixel) {
            document.body.style.cursor = 'move';
          } else {
            document.body.style.cursor = 'default';
          }
          
          // Handle dragging motion
          if (isDragging && isOverNonTransparentPixel) {
            window.transparentWindow.drag(
              e.screenX, 
              e.screenY, 
              dragOffsetX, 
              dragOffsetY
            );
          }
        });
      }

      // Listen for key press to close window (only when over non-transparent pixels)
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'w' && isOverNonTransparentPixel) {
          window.transparentWindow.close();
        }
      });

      // Window dragging with manual positioning
      document.addEventListener('mousedown', (e) => {
        if (isOverNonTransparentPixel) {
          // Start drag if clicked on non-transparent pixel
          isDragging = true;
          
          // Store the current mouse position and offset
          const rect = imageEl.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          
          window.transparentWindow.startDrag();
          
          // Prevent default behaviors
          e.preventDefault();
        }
      });

      // Stop dragging on mouse up
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      // Also stop dragging if mouse leaves the window
      document.addEventListener('mouseleave', () => {
        isDragging = false;
      });
    </script>
  </body>
</html>