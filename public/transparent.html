<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-zoom-pan-pinch@3.3.0/dist/react-zoom-pan-pinch.js" crossorigin></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
      }

      #image-container {
        position: absolute;
        display: block;
        height: 100%;
        width: 100%;
        overflow: hidden;
      }

      .react-transform-component {
        width: 100% !important;
        height: 100% !important;
        overflow: visible !important;
      }

      .react-transform-element {
        cursor: default;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      #png-image {
        position: absolute;
        display: none;
        margin: auto;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        -webkit-user-drag: none;
        transform-origin: center center;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>

    <script>
      console.log('Transparent window HTML loaded');
      
      // Get elements and setup
      const root = document.getElementById('root');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const ctx = hitTestCanvas.getContext('2d');
      
      console.log('Canvas and context initialized');
      
      // State variables
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      let isDragging = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let initialClickOnNonTransparent = false;

      console.log('Variables initialized');

      // Create React components using the globally available React
      const { useState, useEffect, useRef } = React;
      
      // Check if ReactZoomPanPinch is available
      if (!window.ReactZoomPanPinch) {
        console.error('ReactZoomPanPinch is not loaded!');
      } else {
        console.log('ReactZoomPanPinch is available');
      }
      
      const { TransformWrapper, TransformComponent } = window.ReactZoomPanPinch || {};

      const ImageViewer = ({ imageData }) => {
        console.log('ImageViewer component rendering with data:', imageData ? imageData.substring(0, 50) + '...' : 'null');
        
        const imageRef = useRef(null);
        const [isImageLoaded, setIsImageLoaded] = useState(false);
        
        const handleImageLoad = () => {
          console.log('Image loaded in the viewer');
          const img = imageRef.current;
          if (!img) {
            console.error('Image reference is null');
            return;
          }
          
          // Setup hit-test canvas for transparency detection
          hitTestCanvas.width = img.naturalWidth;
          hitTestCanvas.height = img.naturalHeight;
          ctx.clearRect(0, 0, hitTestCanvas.width, hitTestCanvas.height);
          ctx.drawImage(img, 0, 0);
          
          setIsImageLoaded(true);
          img.style.display = 'block';
          console.log('Hit-test canvas initialized with dimensions:', hitTestCanvas.width, 'x', hitTestCanvas.height);
        };
        
        return React.createElement(
          TransformWrapper,
          {
            initialScale: 1,
            minScale: 0.1,
            maxScale: 10,
            limitToBounds: false,
            doubleClick: { disabled: true },
            wheel: { wheelDisabled: true } // We'll handle wheel events ourselves
          },
          ({ zoomIn, zoomOut }) => (
            React.createElement(
              TransformComponent,
              {
                wrapperStyle: { width: '100%', height: '100%' },
                contentStyle: { display: 'flex', alignItems: 'center', justifyContent: 'center', width: '100%', height: '100%' }
              },
              React.createElement('img', {
                ref: imageRef,
                id: 'png-image',
                src: imageData,
                alt: 'PNG Image',
                style: {
                  WebkitUserDrag: 'none',
                  userSelect: 'none',
                  display: 'none' // Hidden initially until loaded
                },
                onLoad: handleImageLoad
              })
            )
          )
        );
      };
      
      // Listen for image data from the main process
      if (window.transparentWindow) {
        console.log('Setting up transparentWindow.loadImage handler');
        window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
          console.log('Received image data in transparent window:', path);
          imagePath = path;
          
          // Render our React component
          console.log('Rendering React component');
          ReactDOM.render(
            React.createElement(ImageViewer, { imageData }),
            root
          );
          
          // Initialize mouse tracking and interactions
          console.log('Initializing interactions');
          initializeInteractions();
        });
      } else {
        console.error('transparentWindow API is not available!');
      }

      // Check if a pixel at the given coordinates is transparent
      function isPixelTransparent(x, y) {
        const imageEl = document.getElementById('png-image');
        if (!imageEl) {
          console.warn('png-image element not found');
          return true;
        }
        
        const rect = imageEl.getBoundingClientRect();
        
        // Check if coordinates are outside image bounds
        if (
          x < rect.left ||
          x > rect.right ||
          y < rect.top ||
          y > rect.bottom
        ) {
          return true;
        }

        // Convert window coordinates to image coordinates
        const scale = imageEl.naturalWidth / rect.width;
        const imgX = Math.floor(((x - rect.left) / rect.width) * hitTestCanvas.width);
        const imgY = Math.floor(((y - rect.top) / rect.height) * hitTestCanvas.height);
        
        // Check if coordinates are within canvas bounds
        if (
          imgX < 0 || 
          imgX >= hitTestCanvas.width || 
          imgY < 0 || 
          imgY >= hitTestCanvas.height
        ) {
          return true;
        }

        // Get pixel data (RGBA)
        try {
          const pixelData = ctx.getImageData(imgX, imgY, 1, 1).data;
          // Check alpha channel (index 3) for transparency
          return pixelData[3] === 0;
        } catch (error) {
          console.error('Error checking pixel transparency:', error);
          return true; // Assume transparent on error
        }
      }

      function initializeInteractions() {
        console.log('Initializing interactions');
        
        // Handle mouse move for pixel transparency detection and dragging
        document.addEventListener('mousemove', (e) => {
          // If dragging is in progress, always move the window regardless of current pixel
          if (isDragging) {
            try {
              // Ensure all values are proper numbers
              const screenX = Number(e.screenX);
              const screenY = Number(e.screenY);
              const offsetX = Number(dragOffsetX);
              const offsetY = Number(dragOffsetY);
              
              if (window.transparentWindow) {
                window.transparentWindow.drag(screenX, screenY, offsetX, offsetY);
              } else {
                console.error('transparentWindow.drag is not available');
              }
            } catch (error) {
              console.error('Error during drag:', error);
              isDragging = false; // Stop dragging on error
            }
            return;
          }
          
          // Not dragging, just check if we're over a non-transparent pixel
          isOverNonTransparentPixel = !isPixelTransparent(e.clientX, e.clientY);
          
          // Update cursor based on transparency
          document.body.style.cursor = isOverNonTransparentPixel ? 'move' : 'default';
        });

        // Initialize window dragging
        document.addEventListener('mousedown', (e) => {
          console.log('Mouse down at', e.clientX, e.clientY);
          initialClickOnNonTransparent = !isPixelTransparent(e.clientX, e.clientY);
          
          if (initialClickOnNonTransparent) {
            // Start drag if clicked on non-transparent pixel
            isDragging = true;
            
            // Calculate and store the click offset relative to the window
            dragOffsetX = e.clientX;
            dragOffsetY = e.clientY;
            
            // Tell the main process dragging has started
            try {
              if (window.transparentWindow) {
                window.transparentWindow.startDrag();
              } else {
                console.error('transparentWindow.startDrag is not available');
              }
            } catch (error) {
              console.error('Error starting drag:', error);
              isDragging = false;
            }
            
            // Prevent default behaviors
            e.preventDefault();
          }
          // If clicked on transparent area, do nothing so the click passes through
        });

        // Handle drag end
        window.addEventListener('mouseup', () => {
          console.log('Mouse up - ending drag');
          isDragging = false;
          initialClickOnNonTransparent = false;
        });

        // Also handle mouseup outside the window
        window.addEventListener('blur', () => {
          console.log('Window blur - ending drag');
          isDragging = false;
          initialClickOnNonTransparent = false;
        });
        
        // Listen for key press to close window (only when over non-transparent pixels)
        document.addEventListener('keydown', (e) => {
          console.log('Key pressed:', e.key);
          if (e.key.toLowerCase() === 'w' && isOverNonTransparentPixel) {
            console.log('Closing window with W key');
            if (window.transparentWindow) {
              window.transparentWindow.close();
            } else {
              console.error('transparentWindow.close is not available');
            }
          }
        });

        // Add mouse wheel event for zooming
        document.addEventListener('wheel', (e) => {
          if (isOverNonTransparentPixel) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            try {
              const transformWrapper = document.querySelector('.react-transform-wrapper');
              if (!transformWrapper) {
                console.error('Transform wrapper not found');
                return;
              }
              
              // Get zoom functions from React component
              const wrapperInstance = transformWrapper._reactProps || transformWrapper.__reactProps$;
              
              if (wrapperInstance && wrapperInstance.children && typeof wrapperInstance.children === 'function') {
                const { zoomIn, zoomOut } = wrapperInstance.children();
                
                if (e.deltaY < 0 && zoomIn) {
                  // Zoom in
                  zoomIn(0.1);
                  console.log('Zooming in');
                } else if (e.deltaY > 0 && zoomOut) {
                  // Zoom out
                  zoomOut(0.1);
                  console.log('Zooming out');
                }
              } else {
                console.log('Using fallback zoom method');
                // Fallback zoom method - use CSS transform directly
                const imageEl = document.getElementById('png-image');
                if (!imageEl) return;
                
                const transformElement = document.querySelector('.react-transform-element');
                if (!transformElement) return;
                
                const currentTransform = window.getComputedStyle(transformElement).transform;
                let scale = 1;
                
                if (currentTransform && currentTransform !== 'none') {
                  const matrix = currentTransform.match(/^matrix\((.+)\)$/);
                  if (matrix) {
                    const values = matrix[1].split(',');
                    scale = Number(values[0]);
                  }
                }
                
                // Update scale based on wheel direction
                if (e.deltaY < 0) {
                  // Zoom in
                  scale = Math.min(scale + 0.1, 10);
                  console.log('Fallback zoom in to', scale);
                } else {
                  // Zoom out
                  scale = Math.max(scale - 0.1, 0.1);
                  console.log('Fallback zoom out to', scale);
                }
                
                transformElement.style.transform = `matrix(${scale}, 0, 0, ${scale}, 0, 0)`;
              }
            } catch (error) {
              console.error('Error during zoom:', error);
            }
          }
        }, { passive: false });

        console.log('All event listeners initialized');
      }

      // For testing - render directly if no image is provided within 5 seconds
      setTimeout(() => {
        if (!document.getElementById('png-image') || document.getElementById('png-image').style.display === 'none') {
          console.log('No image loaded after timeout - rendering test image');
          // Create a simple test image
          const testImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAnElEQVR42u3RAQ0AAAjDMO5fNCCDkC5z0HXTBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQBEEQZGzAA6Ke5T0WR7EDAAAAAElFTkSuQmCC';
          
          // Render our React component with the test image
          ReactDOM.render(
            React.createElement(ImageViewer, { imageData: testImage }),
            root
          );
          
          // Initialize mouse tracking and interactions
          initializeInteractions();
        }
      }, 5000);

      console.log('Transparent window script initialization complete');
    </script>
  </body>
</html>