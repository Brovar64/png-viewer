<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>PNG Viewer - Transparent Window</title>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: transparent;
      }

      body {
        user-select: none;
      }

      #image-container {
        position: absolute;
        display: block;
        height: 100%;
        width: 100%;
        overflow: visible;
        box-sizing: border-box;
      }

      #png-image {
        position: absolute;
        display: none;
        margin: auto;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        -webkit-user-drag: none;
        transform-origin: center center;
      }

      #crop-overlay {
        position: absolute;
        display: none;
        top: 0;
        left: 0;
        border: 2px dashed #ffffff;
        background-color: rgba(0, 0, 0, 0.3);
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        z-index: 10;
        pointer-events: none;
      }

      .crop-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background-color: #ffffff;
        border: 1px solid #000000;
        pointer-events: all;
        z-index: 11;
      }

      .crop-handle-nw { top: -6px; left: -6px; cursor: nw-resize; }
      .crop-handle-ne { top: -6px; right: -6px; cursor: ne-resize; }
      .crop-handle-sw { bottom: -6px; left: -6px; cursor: sw-resize; }
      .crop-handle-se { bottom: -6px; right: -6px; cursor: se-resize; }
      
      .crop-handle-n { top: -6px; left: 50%; margin-left: -6px; cursor: n-resize; }
      .crop-handle-e { top: 50%; right: -6px; margin-top: -6px; cursor: e-resize; }
      .crop-handle-s { bottom: -6px; left: 50%; margin-left: -6px; cursor: s-resize; }
      .crop-handle-w { top: 50%; left: -6px; margin-top: -6px; cursor: w-resize; }
    </style>
  </head>
  <body>
    <div id="image-container">
      <img id="png-image" alt="PNG Image" />
      <div id="crop-overlay">
        <div class="crop-handle crop-handle-nw"></div>
        <div class="crop-handle crop-handle-n"></div>
        <div class="crop-handle crop-handle-ne"></div>
        <div class="crop-handle crop-handle-e"></div>
        <div class="crop-handle crop-handle-se"></div>
        <div class="crop-handle crop-handle-s"></div>
        <div class="crop-handle crop-handle-sw"></div>
        <div class="crop-handle crop-handle-w"></div>
      </div>
    </div>
    <canvas id="hit-test-canvas" style="display: none;"></canvas>

    <script>
      // Get elements
      const imageEl = document.getElementById('png-image');
      const imageContainer = document.getElementById('image-container');
      const hitTestCanvas = document.getElementById('hit-test-canvas');
      const cropOverlay = document.getElementById('crop-overlay');
      const ctx = hitTestCanvas.getContext('2d');
      
      let isOverNonTransparentPixel = false;
      let imagePath = '';
      
      // For dragging
      let isDragging = false;
      let dragStarted = false;
      let dragStartX = 0;
      let dragStartY = 0;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let initialClickOnNonTransparent = false;

      // For zooming
      let scale = 1;
      const minScale = 0.1;
      const maxScale = 10;
      const scaleStep = 0.1;

      // For image crop mode
      let cropMode = false;
      let isCropping = false;
      let cropStartX = 0;
      let cropStartY = 0;
      let cropEndX = 0;
      let cropEndY = 0;
      let activeCropHandle = null;
      
      // For resize window to fit image
      let originalWidth = 0;
      let originalHeight = 0;

      // Adjustable image position
      let imageX = 0;
      let imageY = 0;

      // Listen for image data from the main process
      window.transparentWindow.loadImage(({ imageData, imagePath: path }) => {
        imagePath = path;
        imageEl.src = imageData;
        imageEl.style.display = 'block';
        
        // Once image is loaded, prepare hit-testing canvas
        imageEl.onload = () => {
          // Store original dimensions
          originalWidth = imageEl.naturalWidth;
          originalHeight = imageEl.naturalHeight;
          
          // Size canvas to match image
          hitTestCanvas.width = originalWidth;
          hitTestCanvas.height = originalHeight;
          
          // Draw the image onto the canvas for pixel data access
          ctx.drawImage(imageEl, 0, 0);

          // Center the image initially
          centerImage();

          // Apply initial scale
          applyTransform();

          // Initialize tracking
          initializeInteractions();
          
          // Resize window to fit image better
          if (originalWidth > 100 && originalHeight > 100) {
            window.transparentWindow.resizeWindow(
              Math.min(originalWidth + 100, 1200),
              Math.min(originalHeight + 100, 900)
            );
          }
        };
      });

      // Center the image in the container
      function centerImage() {
        const containerRect = imageContainer.getBoundingClientRect();
        imageX = (containerRect.width - imageEl.width) / 2;
        imageY = (containerRect.height - imageEl.height) / 2;
      }

      // Apply current scale and position to the image
      function applyTransform() {
        imageEl.style.transform = `translate(${imageX}px, ${imageY}px) scale(${scale})`;
      }

      // Toggle crop mode
      function toggleCropMode() {
        cropMode = !cropMode;
        
        if (cropMode) {
          // Enter crop mode
          const rect = imageEl.getBoundingClientRect();
          cropOverlay.style.display = 'block';
          
          // Start with default crop area (centered 50% of image)
          cropStartX = rect.left + rect.width * 0.25;
          cropStartY = rect.top + rect.height * 0.25;
          cropEndX = rect.left + rect.width * 0.75;
          cropEndY = rect.top + rect.height * 0.75;
          
          updateCropOverlay();
        } else {
          // Exit crop mode
          cropOverlay.style.display = 'none';
        }
      }
      
      // Physically crop the window to the selected area
      function applyCrop() {
        if (!cropMode) return;
        
        // Get crop dimensions
        const left = Math.min(cropStartX, cropEndX);
        const top = Math.min(cropStartY, cropEndY);
        const width = Math.abs(cropEndX - cropStartX);
        const height = Math.abs(cropEndY - cropStartY);
        
        if (width < 50 || height < 50) {
          console.error('Crop area too small');
          return;
        }
        
        const imageRect = imageEl.getBoundingClientRect();
        
        // Calculate the scale factor between the window and the displayed image
        const scaleFactorX = originalWidth / (imageRect.width / scale);
        const scaleFactorY = originalHeight / (imageRect.height / scale);
        
        // Convert crop area coordinates to image coordinates
        const cropImageX = (left - imageRect.left) * scaleFactorX / scale;
        const cropImageY = (top - imageRect.top) * scaleFactorY / scale;
        const cropImageWidth = width * scaleFactorX / scale;
        const cropImageHeight = height * scaleFactorY / scale;
        
        // Create a new canvas for the cropped image
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = cropImageWidth;
        cropCanvas.height = cropImageHeight;
        const cropCtx = cropCanvas.getContext('2d');
        
        // Draw only the cropped portion
        cropCtx.drawImage(
          hitTestCanvas, 
          cropImageX, 
          cropImageY, 
          cropImageWidth, 
          cropImageHeight,
          0, 
          0, 
          cropImageWidth, 
          cropImageHeight
        );
        
        // Convert to base64
        const croppedImageData = cropCanvas.toDataURL('image/png');
        
        // Update the window to show only the cropped part
        try {
          window.transparentWindow.updateCroppedImage(croppedImageData, width, height);
          
          // Reset crop mode
          cropMode = false;
          cropOverlay.style.display = 'none';
        } catch (error) {
          console.error('Error applying crop:', error);
        }
      }

      // Update the crop overlay position and dimensions
      function updateCropOverlay() {
        // Ensure start position is always top-left corner
        const left = Math.min(cropStartX, cropEndX);
        const top = Math.min(cropStartY, cropEndY);
        const width = Math.abs(cropEndX - cropStartX);
        const height = Math.abs(cropEndY - cropStartY);
        
        cropOverlay.style.left = `${left}px`;
        cropOverlay.style.top = `${top}px`;
        cropOverlay.style.width = `${width}px`;
        cropOverlay.style.height = `${height}px`;
      }

      // Check if a pixel at the given coordinates is transparent
      function isPixelTransparent(x, y) {
        const rect = imageEl.getBoundingClientRect();
        
        // Check if coordinates are outside image bounds
        if (
          x < rect.left ||
          x > rect.right ||
          y < rect.top ||
          y > rect.bottom
        ) {
          return true;
        }

        // Convert window coordinates to image coordinates
        const imgX = Math.floor(((x - rect.left) / rect.width) * hitTestCanvas.width);
        const imgY = Math.floor(((y - rect.top) / rect.height) * hitTestCanvas.height);
        
        // Check if coordinates are within canvas bounds
        if (
          imgX < 0 || 
          imgX >= hitTestCanvas.width || 
          imgY < 0 || 
          imgY >= hitTestCanvas.height
        ) {
          return true;
        }

        // Get pixel data (RGBA)
        try {
          const pixelData = ctx.getImageData(imgX, imgY, 1, 1).data;
          // Check alpha channel (index 3) for transparency
          return pixelData[3] === 0;
        } catch (error) {
          console.error('Error checking pixel transparency:', error);
          return true; // Assume transparent on error
        }
      }
      
      // Crop handle events
      function initializeCropHandles() {
        const handles = document.querySelectorAll('.crop-handle');
        
        handles.forEach(handle => {
          handle.addEventListener('mousedown', (e) => {
            if (!cropMode) return;
            
            e.stopPropagation();
            e.preventDefault();
            
            activeCropHandle = handle.className.split(' ')[1];
            isCropping = true;
          });
        });
      }
      
      // Update crop based on handle drag
      function updateCropFromHandle(e) {
        if (!activeCropHandle) return;
        
        const cropRect = cropOverlay.getBoundingClientRect();
        
        switch (activeCropHandle) {
          case 'crop-handle-nw':
            cropStartX = e.clientX;
            cropStartY = e.clientY;
            break;
          case 'crop-handle-ne':
            cropEndX = e.clientX;
            cropStartY = e.clientY;
            break;
          case 'crop-handle-se':
            cropEndX = e.clientX;
            cropEndY = e.clientY;
            break;
          case 'crop-handle-sw':
            cropStartX = e.clientX;
            cropEndY = e.clientY;
            break;
          case 'crop-handle-n':
            cropStartY = e.clientY;
            break;
          case 'crop-handle-e':
            cropEndX = e.clientX;
            break;
          case 'crop-handle-s':
            cropEndY = e.clientY;
            break;
          case 'crop-handle-w':
            cropStartX = e.clientX;
            break;
        }
        
        updateCropOverlay();
      }

      function initializeInteractions() {
        // Initialize crop handles
        initializeCropHandles();
        
        // Handle mouse move for pixel transparency detection and dragging
        document.addEventListener('mousemove', (e) => {
          // Handle crop resizing
          if (isCropping && cropMode) {
            updateCropFromHandle(e);
            return;
          }
          
          // If dragging is in progress, always move the window regardless of current pixel
          if (isDragging) {
            try {
              // Ensure all values are proper numbers
              const screenX = Number(e.screenX);
              const screenY = Number(e.screenY);
              const offsetX = Number(dragOffsetX);
              const offsetY = Number(dragOffsetY);
              
              window.transparentWindow.drag(screenX, screenY, offsetX, offsetY);
            } catch (error) {
              console.error('Error during drag:', error);
              isDragging = false; // Stop dragging on error
            }
            return;
          }
          
          // Not dragging, just check if we're over a non-transparent pixel
          isOverNonTransparentPixel = !isPixelTransparent(e.clientX, e.clientY);
          
          // Update cursor based on transparency (unless in crop mode)
          if (!cropMode) {
            document.body.style.cursor = isOverNonTransparentPixel ? 'move' : 'default';
          }
        });

        // Initialize window dragging
        document.addEventListener('mousedown', (e) => {
          // Don't start window drag if in crop mode
          if (cropMode) {
            // Start a new crop area
            if (!isCropping && cropOverlay.style.display === 'block') {
              cropStartX = e.clientX;
              cropStartY = e.clientY;
              cropEndX = e.clientX;
              cropEndY = e.clientY;
              isCropping = true;
            }
            return;
          }
          
          initialClickOnNonTransparent = !isPixelTransparent(e.clientX, e.clientY);
          
          if (initialClickOnNonTransparent) {
            // Start drag if clicked on non-transparent pixel
            isDragging = true;
            
            // Calculate and store the click offset relative to the window
            const rect = imageEl.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Tell the main process dragging has started
            try {
              window.transparentWindow.startDrag();
            } catch (error) {
              console.error('Error starting drag:', error);
              isDragging = false;
            }
            
            // Prevent default behaviors
            e.preventDefault();
          }
          // If clicked on transparent area, do nothing so the click passes through
        });

        // Handle drag end
        window.addEventListener('mouseup', (e) => {
          if (isCropping) {
            // Finish crop
            isCropping = false;
            activeCropHandle = null;
            
            // Only create a valid crop area if big enough
            if (Math.abs(cropEndX - cropStartX) > 10 && Math.abs(cropEndY - cropStartY) > 10) {
              updateCropOverlay();
            }
          }
          
          isDragging = false;
          initialClickOnNonTransparent = false;
        });

        // Also handle mouseup outside the window
        window.addEventListener('blur', () => {
          isDragging = false;
          initialClickOnNonTransparent = false;
          isCropping = false;
          activeCropHandle = null;
        });
        
        // Listen for key press
        document.addEventListener('keydown', (e) => {
          // Only handle keyboard shortcuts when over the image
          if (!isOverNonTransparentPixel && !cropMode) return;
          
          // Close with 'W' key
          if (e.key.toLowerCase() === 'w') {
            window.transparentWindow.close();
          }
          
          // Toggle crop mode with 'R' key
          if (e.key.toLowerCase() === 'r') {
            toggleCropMode();
          }
          
          // Apply crop with Enter key
          if (e.key === 'Enter' && cropMode) {
            applyCrop();
          }
          
          // Cancel crop with Escape key
          if (e.key === 'Escape' && cropMode) {
            cropMode = false;
            cropOverlay.style.display = 'none';
          }
        });

        // Add mouse wheel event for zooming
        document.addEventListener('wheel', (e) => {
          // Don't zoom when in crop mode
          if (cropMode) return;
          
          if (isOverNonTransparentPixel) {
            // Prevent default scrolling behavior
            e.preventDefault();
            
            // Save current mouse position relative to image before scaling
            const rect = imageEl.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const mouseXRatio = mouseX / rect.width;
            const mouseYRatio = mouseY / rect.height;
            
            // Previous dimensions
            const prevWidth = rect.width;
            const prevHeight = rect.height;
            
            // Calculate new scale based on wheel direction
            const oldScale = scale;
            if (e.deltaY < 0) {
              // Scroll up - zoom in
              scale = Math.min(scale + scaleStep, maxScale);
            } else {
              // Scroll down - zoom out
              scale = Math.max(scale - scaleStep, minScale);
            }
            
            // Calculate how the dimensions will change
            const scaleFactor = scale / oldScale;
            const newWidth = prevWidth * scaleFactor;
            const newHeight = prevHeight * scaleFactor;
            
            // Adjust position to zoom toward mouse pointer
            imageX -= (newWidth - prevWidth) * mouseXRatio;
            imageY -= (newHeight - prevHeight) * mouseYRatio;
            
            // Apply the new transform
            applyTransform();
            
            // If in crop mode, update the overlay
            if (cropMode) {
              updateCropOverlay();
            }
          }
        }, { passive: false });
      }
    </script>
  </body>
</html>